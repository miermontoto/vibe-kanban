# Ralph Wiggum Mode

Ralph Wiggum is a loop-until-complete execution pattern for coding agents, inspired by [Claude Code's Ralph Wiggum plugin](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum).

## How It Works

### Prompt Wrapping

When Ralph Wiggum mode is enabled on a task, the system automatically wraps the task prompt with completion criteria and looping instructions:

```rust
// Original prompt
"Implement user authentication"

// Wrapped prompt (generated by Task::to_prompt())
"Implement user authentication

IMPORTANT COMPLETION CRITERIA:
- Work on this task iteratively until all requirements are met
- Maximum iterations allowed: 10
- Test and validate your work thoroughly
- When you have fully completed all requirements and all tests pass,
  output exactly: <promise>COMPLETE</promise>
- Do NOT output the completion promise unless the task is actually complete

The task will loop until you output the completion signal or reach the iteration limit."
```

### Execution Model

**IMPORTANT**: The vibe-kanban backend does **not** enforce the looping logic. Instead:

1. **Backend Role**:
   - Stores Ralph Wiggum configuration (enabled, max_iterations, completion_promise)
   - Automatically wraps prompts via `Task::to_prompt()` when Ralph Wiggum is enabled
   - Passes the wrapped prompt to the executor

2. **Executor Role** (Claude Code, etc.):
   - Receives the wrapped prompt with completion criteria
   - Implements the actual looping logic:
     - Tracks iteration count
     - Detects `<promise>{signal}</promise>` in agent output
     - Re-invokes the agent with the same prompt until complete or max iterations reached
     - Handles test validation, error recovery, etc.

### Why This Design?

This separation of concerns provides:

- **Flexibility**: Different executors can implement looping differently
- **Simplicity**: Backend doesn't need complex state management for iterations
- **Compatibility**: Works with any executor that understands the wrapped prompt format
- **Testability**: Prompt wrapping can be tested independently of execution

### Executor Requirements

For an executor to support Ralph Wiggum mode, it must:

1. Parse the wrapped prompt and extract:
   - Max iterations limit
   - Completion signal pattern
2. Implement a loop that:
   - Invokes the agent with the wrapped prompt
   - Checks output for `<promise>{signal}</promise>`
   - Stops when signal detected OR max iterations reached
3. Handle the completion signal appropriately (e.g., mark task as done)

### Example: Claude Code Integration

Claude Code's native Ralph Wiggum plugin already implements this pattern:

```typescript
// Claude Code automatically:
// 1. Detects the completion criteria in the prompt
// 2. Loops the agent invocation
// 3. Monitors for the <promise>COMPLETE</promise> signal
// 4. Tracks iteration count
// 5. Stops at max_iterations or when complete
```

When using vibe-kanban with Claude Code, enabling Ralph Wiggum mode works seamlessly because both use the same completion signal pattern.

### Configuration

#### Via UI (Frontend)

When creating or editing a task, enable the "Ralph Wiggum mode" toggle to configure:

- **Enabled**: Whether to use Ralph Wiggum mode
- **Max Iterations**: Maximum number of agent invocations (default: 10)
- **Completion Signal**: The signal to detect in agent output (default: "COMPLETE")

#### Via MCP (Model Context Protocol)

The MCP server exposes Ralph Wiggum settings in both `create_task` and `update_task` tools:

```json
{
  "name": "create_task",
  "parameters": {
    "project_id": "uuid",
    "title": "Implement feature X",
    "description": "Details...",
    "use_ralph_wiggum": true,
    "ralph_max_iterations": 15,
    "ralph_completion_promise": "DONE"
  }
}
```

### Best Practices

1. **Set Appropriate Limits**:
   - Simple tasks: 5-10 iterations
   - Complex features: 15-20 iterations
   - Avoid very high limits to prevent runaway execution

2. **Clear Completion Criteria**: Include specific, testable requirements in the task description

3. **Custom Signals**: Use custom completion promises for multi-stage workflows:
   ```
   Stage 1: <promise>TESTS_PASS</promise>
   Stage 2: <promise>DOCS_COMPLETE</promise>
   ```

4. **Monitor Progress**: Check agent logs to see iteration count and why loops terminated

### Limitations

- Backend doesn't track iteration history (executor's responsibility)
- No automatic rollback if agent fails midway through iterations
- Completion signal must be exact match (case-sensitive)
- Only works with executors that understand the prompt format

### Future Enhancements

Potential improvements for future versions:

- **Backend iteration tracking**: Store iteration history in the database
- **Partial completion signals**: Support intermediate checkpoints
- **Adaptive limits**: Dynamically adjust max_iterations based on task complexity
- **Executor detection**: Auto-enable for compatible executors
- **Iteration analytics**: Dashboard showing average iterations per task type
